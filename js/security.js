/**
 * Client-Side Security Module
 * NOTE: This is a client-side measure. Robust security requires server-side validation, 
 * firewalls (e.g., Cloudflare), HTTPS, and backend authentication.
 */

const SecurityGuard = {
  config: {
    MAX_FORM_ATTEMPTS: 3,
    LOCKOUT_DURATION: 300000, // 5 minutes in milliseconds
    SUSPICIOUS_PATTERNS: [
      /(\bor\b|\bunion\b|\bselect\b|\binsert\b|\bupdate\b|\bdelete\b|\bdrop\b|\btruncate\b)/gi, // SQL injection
      /(<script|<iframe|javascript:|onerror=|onclick=)/gi, // XSS patterns
      /(%27)|(')|(--)|(;)|(\|)|(\/\/)/g // Common SQL injection characters
    ]
  },

  // NOTE: This is a client-side measure. Server-side validation is essential.
  sanitizeInput(input) {
    if (typeof input !== 'string') return input;
    
    // Remove potential HTML/Script tags
    const div = document.createElement('div');
    div.textContent = input;
    return div.innerHTML;
  },

  // NOTE: This is a client-side measure. Server-side rate limiting is essential.
  checkRateLimit(formId) {
    const key = `form_attempts_${formId}`;
    const lockoutKey = `form_lockout_${formId}`;
    
    // Check if currently in lockout
    const lockoutTime = sessionStorage.getItem(lockoutKey);
    if (lockoutTime) {
      const remainingTime = parseInt(lockoutTime) - Date.now();
      if (remainingTime > 0) {
        const minutes = Math.ceil(remainingTime / 60000);
        return {
          allowed: false,
          message: `For your security, this form has been temporarily disabled. Please try again in ${minutes} minute${minutes > 1 ? 's' : ''} or contact the parish office directly.`
        };
      } else {
        sessionStorage.removeItem(lockoutKey);
        sessionStorage.removeItem(key);
      }
    }
    
    // Increment attempt counter
    let attempts = parseInt(sessionStorage.getItem(key) || '0');
    attempts++;
    sessionStorage.setItem(key, attempts.toString());
    
    if (attempts > this.config.MAX_FORM_ATTEMPTS) {
      const lockoutUntil = Date.now() + this.config.LOCKOUT_DURATION;
      sessionStorage.setItem(lockoutKey, lockoutUntil.toString());
      return {
        allowed: false,
        message: `For your security, this form has been temporarily disabled. Please try again later or contact the parish office directly.`
      };
    }
    
    return { allowed: true };
  },

  // NOTE: This is a client-side measure. Log events server-side for actual security.
  detectSuspiciousPatterns(input) {
    if (typeof input !== 'string') return [];
    
    const detectedPatterns = [];
    this.config.SUSPICIOUS_PATTERNS.forEach((pattern, index) => {
      if (pattern.test(input)) {
        detectedPatterns.push(index);
      }
    });
    
    if (detectedPatterns.length > 0) {
      console.warn('âš ï¸ Suspicious input pattern detected:', {
        timestamp: new Date().toISOString(),
        patterns: detectedPatterns,
        // NOTE: Input content NOT logged for privacy. Log server-side if needed.
        message: 'This input contains patterns that may indicate malicious intent.'
      });
    }
    
    return detectedPatterns;
  },

  // NOTE: This is a client-side measure. Server-side CSRF token validation is essential.
  generateCSRFToken() {
    // In a real application, this would be generated by the server
    // This is a placeholder to show where CSRF protection would be integrated
    const token = `csrf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    sessionStorage.setItem('csrf_token', token);
    return token;
  },

  // NOTE: This is a client-side measure. True validation and sanitization must happen server-side.
  validateFormData(formData, rules = {}) {
    const errors = [];
    
    for (const [field, value] of formData.entries()) {
      // Skip hidden CSRF tokens
      if (field === 'csrf_token') continue;
      
      // Detect suspicious patterns
      const suspiciousPatterns = this.detectSuspiciousPatterns(value);
      if (suspiciousPatterns.length > 0) {
        errors.push({
          field,
          type: 'suspicious_pattern',
          message: 'This field contains suspicious content. Please review your input.'
        });
      }
      
      // Apply custom rules if provided
      if (rules[field]) {
        const fieldErrors = rules[field](value);
        if (fieldErrors) {
          errors.push(...fieldErrors);
        }
      }
    }
    
    return {
      isValid: errors.length === 0,
      errors
    };
  },

  // NOTE: This is a client-side measure. Integrity verification must happen server-side.
  addIntegrityCheck(form) {
    if (!form) return;
    
    // Create a hidden CSRF token field if it doesn't exist
    if (!form.querySelector('input[name="csrf_token"]')) {
      const csrfInput = document.createElement('input');
      csrfInput.type = 'hidden';
      csrfInput.name = 'csrf_token';
      csrfInput.value = this.generateCSRFToken();
      form.appendChild(csrfInput);
    }
  },

  // Initialize security measures
  init() {
    console.log('ðŸ›¡ï¸ Security Guard initialized - Client-side protections active');
    console.log('âš ï¸ NOTE: Server-side validation, firewalls, and HTTPS are required for production security');
    
    // Add CSRF tokens to all forms
    document.querySelectorAll('form').forEach(form => {
      this.addIntegrityCheck(form);
    });
  }
};

// Initialize on DOM ready
document.addEventListener('DOMContentLoaded', () => SecurityGuard.init());

// Export for use in other scripts
if (typeof module !== 'undefined' && module.exports) {
  module.exports = SecurityGuard;
}
